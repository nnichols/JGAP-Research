Improvements to Genetic Algorithms are frequently compared based upon their abilities to solve various benchmark numerical functions and real world problems like the Traveling Salesman and Job Scheduling problems\cite{molga05}. In order to get a good grasp on the general behavior of elitist schemata overlays in comparison to the other tested operators, we have chosen a variety of problems from both of these fields. 

Our research found a set of common minimization functions used as benchmarks of the performance of new Genetic Algorithms\cite{Deb99,Eiben95,Tsutsui99}. These functions should give us a picture of how well our algorithm compares to more traditional ones. In order to make some reasoning about the behavior of elitist schemata overlays on real world problems, we will also test performance on several instances of the Knapsack and Traveling Salesman problems. Finally, each of the genetic operators will be ran on several NK-Landscapes, a common testing tool for Genetic Algorithms.

\subsection*{Minimization Functions}
\subsubsection*{Definitions}

%
% De Jong Sphere Definition
%
The sphere De Jong function is both convex and unimodal with a global minimum of $0$ located at $(0,0,\ldots,0)$. The n-dimensional version of the sphere function is as defined\cite{molga05,yang10}:
\[ f(x_1,x_2,\ldots,x_n) = \sum\limits_{i=1}^n x_i^2 \text{ for } -5.12 \leq x_i \leq 5.12 \]
%
%De Jong Hyper-Ellipsoid Definition
%
The hyper-ellipsoid function is defined similarly, and maintains the global minimum of $0$ located at $(0,0,\ldots,0)$.\cite{molga05,yang10}:
\[ f(x_1,x_2,\ldots,x_n) = \sum\limits_{i=1}^n ix_i^2 \text{ for } -5.12 \leq x_i \leq 5.12\]
%
% Sum of Different Powers Function
%
We also selected the closely related sum of different powers function, whose minimum is also of $0$ located at $(0,0,\ldots,0)$\cite{molga05,yang10}:
\[ f(x_1,x_2,\ldots,x_n) = \sum\limits_{i=1}^n |x_i|^{i+1} \text{ for } -1 \leq x_i \leq 1\]
%
% Griewank's Function
%
The Griewank function is known for its multi-modality and also has its global minimum of $0$ located at $(0,0,\ldots,0)$\cite{molga05,yang10}:
 \[ f(x_1,x_2,\ldots,x_n) = \frac{1}{4000}\sum\limits_{i=1}^n x_i^{2} - \prod\limits_{i=1}^{n} \cos(\frac{x_i}{\sqrt{i}})+1 \text{ for } -600 \leq x_i \leq 600\]
 %
 % 2-D Michaelwicz Function
 %
 The two dimensional Michaelwicz function has a global minimum approximately equal to $-1.8013$ at the approximate points $(2.2032,1.5705)$ and is defined below\cite{molga05,yang10}:
 \[ f(x,y) = -\sin(x)\sin^{20}(\frac{x^2}{\pi}) - \sin(y)\sin^{20}(\frac{2y^2}{\pi}) \text{ for } 0 \leq x,y \leq 5\]
 %
 % Rastrigin's Function
 %
 Rastrigin's Function is another highly multimodal function with a global minimum of $0$ at $(0,0,\ldots,0)$ \cite{molga05,yang10}:
 \[f(x_1,x_2,\ldots,x_n) = \sum\limits_{i=1}^n \big( x_i^2 - 10\cos(2\pi x_i) \big)\text{ for } -600 \leq x_i \leq 600\]
 %
 % Rosenbrock's Function
 %
 Rosenbrock's function has a global minimum of 0 at $(1,1,\ldots,1)$ \cite{molga05,yang10}:
 \[f(x_1,x_2,\ldots,x_n) = \sum\limits_{i=1}^{n-1} ((x_i-1)^2 + 100(x_{i+1}-x_i^2)^2) \text{ for } -5 \leq x_i \leq 5\]
 %
 % Six Hump Camel Back Function
 %
 The two-dimensional six-hump camel back function has a global minimum of approximately $-1.0316$ at the coordinates $(0.0898,-0.7126)$ and $(-0.0898,0.7126)$\cite{molga05,yang10}:
 \[f(x,y) = \frac{x^6}{3}-2.1x^4+4x^2+xy+4y^4-4y^2 \]
 %
 % Schubert's 2D Function
 %
 Schubert's function is multimodal and has $18$ global minima of approximate value $-186.7309$ in the given search domain \cite{molga05,yang10}:
 \[ f(x,y) = (\sum\limits_{i=1}^{5} i\cos(i + ix + x)) * (\sum\limits_{i=1}^{5} i\cos(i + iy + y)) \text{ for } -10 \leq x,y \leq 10 \]
 
 %
 % Encoding
 %
 \subsubsection*{Encoding}
Genetic sequences have traditionally been encoded as both traditional binary strings and \emph{Binary Reflective Gray Codes} \cite{Whitley97}. Gray Codes are modified interpretations of bitstrings that minimize the variation in representation of adjacent values \cite{Back93}. In the traditional binary system, the unsigned values of $2^n$ and $2^n - 1$ have no bits in common over the first $n$ places, even though their values only differ by $1$. In a Gray Coding, all adjacent values differ by exactly one bit \cite{Michalewicz98}. Given a bitstring $a = a_1 a_2 \ldots a_n$, we can described the translation between traditional binary strings and Binary Reflective Gray Codes mathematically. The traditional binary bitstring $a$ can be rewritten as a Binary Reflective Gray Code bitstring $b =  b_1 b_2 \ldots b_n$ with the following function \cite{Back93}:

\begin{displaymath}
   b_i = \left\{
     \begin{array}{cr}
       a_1 & \text{if~ } i = 1 \\
       (a_{i-1} + a_i) \bmod{2} & \text{if~ } i > 1
     \end{array}
   \right.
\end{displaymath} 

Likewise, we can translate between a Binary Reflective Gray Code bitstring $b$ to the traditional binary bitstring $a$ with this procedure \cite{Back93}:

\begin{displaymath}
   a_i = \left\{
     \begin{array}{cr}
       b_1 & \text{if~ } i = 1 \\
       (a_{i-1} + b_i) \bmod{2} & \text{if~ } i > 1
     \end{array}
   \right.
\end{displaymath} 

To describe continuous domains, like those in the test functions presented, we must map our genetic sequences of discrete values to the real numbers. Suppose we wish to operate on a variable $x$ whose domain $D = [a,b] \subseteq \mathbb{R}$, and that we require $k$ decimal places of precision for $x$. To accomplish this, we need to parition $D$ into $10^k(b - a)$ ranges of equivalent length. So we find the smallest $n \in \mathbb{N}$ such that $10^k(b - a) \leq 2^n - 1$. To assign values to $x$ given a genetic sequence $g$ and a decoding function $d$, which takes a genetic sequence and evaluates it to its decimal equivalent \cite{Michalewicz98}:
\[ x = a + d(g) \left( \frac{b-a}{2^n - 1} \right) \]

%
% Knapsack
%
\subsection*{0-1 Knapsack Problem}
\subsubsection*{Definition}

The 0-1 Knapsack Problem is an NP-Hard optimization problem. Let $X$ be the set of items $\{x_1, x_2, \ldots, x_n\}$, $C$ be the set of cost values $\{c_1, c_2, \ldots, c_n\}$, and $B$ be the set of benefit values $\{b_1, b_2, \ldots, b_n\}$. Each item $x_i$, with the domain $\{0,1\}$, has an associated cost $c_i$ and benefit $b_i$, where each $b_i,c_i \in \mathbb{R}^{+}$. Given a cost limit $L$ we want to maximize the sum of the benefit values while not allowing the sum of our cost values to exceed $L$:
\[ max\big( \sum\limits_{i = 1}^{n} b_ix_i \big) \text{ where } \sum\limits_{i = 1}^{n} c_ix_i \leq L \]

\subsubsection*{Encoding}
The  0-1 Knapsack Problem is typically also represented with bitstrings, but these are not evaluated in the same manner as those for continuous domains. For a genetic sequence $g = g_1 g_2 \ldots g_n$, each $g_i$, where $1 \leq i \leq n$, represents the value of the corresponding $x_i$ in the item set $X$ for a given instance of the problem. 

%
% TSP
%
\subsection*{Traveling Salesman Problem}
\subsubsection*{Definition}
The Traveling Salesman Problem from Graph Theory is another NP-Hard problem. Let $V$ be a set of verticies $v_1, v_2, \ldots v_r$ of a graph $G$. The set of edges $E$ is defined such that each $e_i \in E$ is an ordered tuple of the form $(v_j,v_k), j \not = k$ where $v_j,v_k \in V$ are the veriticies that $e_i$ connects. For each $e_n \in E$, there is an associated $w_n \in W$ where $w_n$ is a positive real number that is the weight of the edge $e_n$. The goal of a given Travelling Salesman Problem instance is to find the Hamiltonian Circuit that has the minimum total weight. In other words, we must find a series of edges $T = e_{1},e_{2},\ldots,e_{n}$ such that minimizes the following\cite{Haxhimusa11}:
\[\sum\limits_{e_{i} \in T} w_{i}\]
\noindent Where $w_{i}$ is the weight of the edge $e_{i}$.

\subsubsection*{Encoding}
Permutation based problems, like the Travelling Salesman Problem, break away from the tradition of utilizing binary values to build genetic sequences. Na\"{\i}ve bitstring representations create long genetic sequences that commonly encode infeasible solutions, those that do not meet the constraints of the problem instance, or incorrect genetic sequences, those that are not permutations \cite{Potvin96}. To help correct this, Travelling Salesman Problems of size $n$ can be encoded as a sequence of integers from the set $\{1, 2, \ldots, n\}$ to minimize the length of the genetic sequences. Another common optimization is to fix a single point in all cyclic permutations to reduce the number of representations of an identical solution. 

\subsubsection*{Permutation Repair Algorithm}
For most applications, the described genetic operators will function correctly unmodified; however, for permutation based problems that allow for only one instance of a given value, like the Traveling Salesman Problem, a slight change is necessary. For instance, the application of an overlay might leave identical values in multiple positions in the genetic sequence. Many genetic operators have this effect, and two main solutions are utilized in practice: New genetic operators tailored to these problems, and repair algorithms\cite{Larranaga99}. To keep our choice of operators consistent, we have devised a repair algorithm to use in every necessary case.
\begin{figure}[h!]
\centering 
\begin{align*}
\text{Genetic Overlay} &:   -1~3--6~2-9				\\
\text{New Individual} &: 2~1~3~4~5~7~6~8~9			\\		
\text{Resultant Individual} &: 2~1~3~4~5~6~2~1~9
\end{align*}
\caption{The Permutation Problem with Genetic Overlays}
\label{PRA-Fig}
\end{figure}

As we can see in Figure-\ref{PRA-Fig}, the resultant individual now contains two instances of both 2 and 9. Thus, we need a repair algorithm can be used to correct this example, while maintaining the given genetic overlay. 

Our repair algorithm, whose pseudocode can be found in figure-\ref{PRA-Alg}, iterates through a genetic sequence and counts how often each value is used. On the second pass, we check each value to see if it has been used exactly once in the permutation. If this is true, then we advance to the next allele. We will also skip alleles that are defined in the given genetic overlay. If neither of these conditions are true, we replace the current allele with a value that is not already in the permutation. With this structure, we maintain the invariant that the genetic subsequence from the beginning up to the point we are operating on is a valid permutation.

In order to guarantee that we both do not disturb a given genetic overlay and that our end result is a permutation, we must require that every genetic overlay is a permutation. This constraint is feasible in practice, and we have proven that no elitist schema overlay will ever contain a duplicated value if the population consists of permutations only.

\begin{thm}
An elitist schema overlay will never contain a duplicated element, given that all members of the population are $k$-permutations of $n$ elements where k $\leq$ n.
\end{thm}

To begin, let $e$ be an elitist schema overlay created from a population $P$. It is given that $\forall p \in P$, $p$ must be a $k$-permutation of $n$ elements. Thus, the $x$ most fit individuals in $P$ must also be permutations. Since each of these individuals is a permuataion, none of them may contain duplicate values. By the definition of an elitist schema overlay, $e$ will only be defined for the matching alleles of the $x$ most fit members of $P$. Since none of these members can have duplicate values, $e$ cannot have duplicate values either.

%
% Permutation Repair Algorithm Code
%
\begin{algorithm}
	\SetAlgoLined
	\KwData{A genetic sequence, \emph{seq}, of permutable values and a genetic overlay, \emph{g}} \SetKwData{Seq}{seq} \SetKwData{Value}{value} \SetKwData{Use}{use} \SetKwData{aye}{i} \SetKwData{jay}{j} \SetKwData{gee}{g} \SetKwData{Isdef}{defined}
	\KwResult{\emph{seq}, with values that form a permutation.}
	\BlankLine

	\tcp{Find out how many times each value is used in \Seq}
	\For{$ \Value \in \Seq $}{
		$\Use [ \Value ]  \gets \Use[ \Value ] + 1 $ 
	}
	
	\BlankLine
	\tcp{Correct the sequence}
	\For{ $\aye \gets 0$ \KwTo $\Seq.length$}{

		$\Value \gets \Seq[ \aye ]$		

		
		\tcp{Only check undefined locations in the overlay}
		\If{ $ \gee[ \aye ] = \Isdef $ }{ 
			continue
		}
		\BlankLine

		\tcp{Check if the value has been reused}
		\If{ $ \Use[ \Value ] > 1 $ }{ 
		\BlankLine
			
			\tcp{Find an unused value}
			\For{ $\jay \gets 0$ \KwTo $\Use.length$}{
			\BlankLine
				
				\tcp{Update the usage array and genetic sequence}
				\If{ $\Use[ \jay ] = 0$ }{

					$\Seq[ \aye ] \gets \jay $ \\
					$\Use[ \jay ] \gets 1$  \\
					$\Use[ \Value ] \gets \Use[ \Value ] - 1 $ \\
					break 	
				}
			}
		}
	}

	\caption{Permutation Repair Algorithm Pseudocode}
	\label{PRA-Alg}
\end{algorithm}


\begin{thm}
The result of applying the permutation repair algorithm on a genetic sequence and overlay of length $k$ is always a genetic sequence that is a $k$-permutation of the $n$ possible values for each allele given that $ k \leq n$.
\end{thm}

To prove this theorem via strong induction, we shall begin with the base case of genetic sequences of length 1. Since neither a genetic sequence nor a genetic overlay of length 1 can have any duplicated values, we are done. 

Now we assume that the permutation repair algorithm will work on any genetic sequence and genetic overlay of length $k$, and will return a $k$-permutation of $n$ with the genetic overlay intact. From here, we show that the case of $k \leq n$ follows. We must consider the following cases:
\begin{enumerate}
\item The genetic overlay is defined for all values. 
If this is true, then by the constraint of the algorithm, the genetic overlay must be a permutation. Thus, the sequence resulting from the genetic overlay's application will have identical values to the genetic overlay. Thus, the sequence is already a permutation, and we are done.

\item The genetic overlay is defined for $j$ values, where $0 \leq j \leq k $. 
Consider the subsequence formed by taking an arbitrary $k$ values of the given genetic sequence in order, such that the position \emph{not} selected, $d$, does not appear in the genetic overlay. By the inductive hypothesis, we can use the permutation repair algorithm to change this into a $k$-permutation of $n$ elements. Since $k < n$, there must exist an element $c$ that does not appear in the other $k$ values. If the $d$th value is already set to a unique element, we are done. Else, we can change the $d$th value to $c$ and be done.
\end{enumerate}

%
% NK-Landscapes
%

\subsection*{NK-Landscapes}

Since multi-parent recombination operators have had success on NK-Landscapes in previous studies, we will test each genetic operator on several NK-Landscapes of varying size and ruggedness\cite{Eiben96,Skellett05}. Definitions from current research for these problems and several of their characteristics can be found below\cite{molga05,Skellett05,yang10}.
